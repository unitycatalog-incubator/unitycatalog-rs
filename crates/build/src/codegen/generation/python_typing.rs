//! Python typing generation module for .pyi files
//!
//! This module generates comprehensive Python typing information (.pyi files)
//! for Unity Catalog services to keep types in sync with protobuf definitions.
//!
//! ## Overview
//!
//! The generated `.pyi` file provides complete type annotations for all Unity Catalog
//! Python client classes, methods, and data types. This ensures that Python developers
//! get accurate type hints and IDE support when using the Unity Catalog client.
//!
//! ## Generated Content
//!
//! - **Enum Types**: All protobuf enums extracted from the actual definitions
//! - **Message Types**: Data classes with proper field typing extracted from protobuf
//! - **Client Classes**: Resource-specific clients with methods based on service definitions
//! - **Main Client**: The primary UnityCatalogClient with all collection and accessor methods
//!
//! ## Integration
//!
//! The typing file is automatically generated during the code generation process
//! and is written to `python/client/unitycatalog_client_generated.pyi`.
//! To regenerate, run: `just generate-code`

use crate::analysis::{GenerationPlan, ServicePlan};
use crate::parsing::{CodeGenMetadata, EnumInfo, MessageInfo};

/// Generate comprehensive Python typing file (.pyi) content
pub fn generate_typing_file(
    plan: &GenerationPlan,
    metadata: &CodeGenMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // Add file header and imports
    output.push_str(&generate_header());

    // Generate enum definitions from actual protobuf metadata
    output.push_str(&generate_enum_types_section(metadata));
    output.push('\n');

    // Generate message type definitions from actual protobuf metadata
    output.push_str(&generate_message_types_section(metadata));
    output.push('\n');

    // Generate client class definitions
    output.push_str(&generate_client_classes_section(&plan.services));

    Ok(output)
}

/// Generate file header with imports
fn generate_header() -> String {
    r#"# AUTOGENERATED FILE - DO NOT EDIT
# This file is generated from protobuf definitions.
# To regenerate, run: just generate-code

from __future__ import annotations

import enum
from typing import Dict, List, Literal, Optional, Tuple, Union

"#
    .to_string()
}

/// Generate enum types section
fn generate_enum_types_section(metadata: &CodeGenMetadata) -> String {
    let mut output = String::from("# Enum definitions\n\n");

    // Generate enums from actual protobuf metadata
    for (enum_type_name, enum_info) in &metadata.enums {
        // Skip internal/nested enums that aren't top-level Unity Catalog types
        if should_include_enum(enum_type_name) {
            output.push_str(&generate_enum_definition(enum_info));
            output.push('\n');
        }
    }

    output
}

/// Generate message types section
fn generate_message_types_section(metadata: &CodeGenMetadata) -> String {
    let mut output = String::from("# Message type definitions\n\n");

    // Generate messages from actual protobuf metadata
    for (message_type_name, message_info) in &metadata.messages {
        // Skip internal/request/response types that aren't core Unity Catalog data types
        if should_include_message(message_type_name) {
            output.push_str(&generate_message_definition(message_info, metadata));
            output.push('\n');
        }
    }

    output
}

/// Determine if an enum should be included in the typing file
fn should_include_enum(enum_type_name: &str) -> bool {
    // Include top-level Unity Catalog enums
    enum_type_name.contains("unitycatalog")
        && !enum_type_name.contains("request")
        && !enum_type_name.contains("response")
        && !enum_type_name.contains("::") // Skip nested enums
}

/// Determine if a message should be included in the typing file
fn should_include_message(message_type_name: &str) -> bool {
    // Include Unity Catalog data types but skip request/response messages
    message_type_name.contains("unitycatalog")
        && !message_type_name.to_lowercase().contains("request")
        && !message_type_name.to_lowercase().contains("response")
        && (message_type_name.ends_with("Info")
            || message_type_name.ends_with("Credential")
            || message_type_name.ends_with("Principal")
            || message_type_name.ends_with("Identity")
            || message_type_name.ends_with("Key")
            || message_type_name.ends_with("Object")
            || message_type_name.ends_with("Summary")
            || message_type_name.contains("Azure"))
}

/// Generate enum definition from protobuf metadata
fn generate_enum_definition(enum_info: &EnumInfo) -> String {
    let mut output = String::new();

    // Extract simple class name
    let class_name = extract_simple_type_name(&enum_info.name);

    // Class definition with documentation
    output.push_str(&format!("class {}(enum.IntEnum):\n", class_name));
    if let Some(doc) = &enum_info.documentation {
        let cleaned_doc = clean_documentation(doc);
        output.push_str(&format!("    \"\"\"{}\"\"\"\n", cleaned_doc));
    }
    output.push('\n');

    // Generate enum values
    for value in &enum_info.values {
        output.push_str(&format!("    {} = {}\n", value.name, value.number));
        if let Some(doc) = &value.documentation {
            let cleaned_doc = clean_documentation(doc);
            output.push_str(&format!("    \"\"\"{}.\"\"\"\n", cleaned_doc));
        }
    }

    output
}

/// Generate message definition from protobuf metadata
fn generate_message_definition(message_info: &MessageInfo, _metadata: &CodeGenMetadata) -> String {
    let mut output = String::new();

    // Extract simple class name
    let class_name = extract_simple_type_name(&message_info.name);

    // Class definition with documentation
    output.push_str(&format!("class {}:\n", class_name));
    if let Some(doc) = &message_info.documentation {
        let cleaned_doc = clean_documentation(doc);
        output.push_str(&format!("    \"\"\"{}\"\"\"\n", cleaned_doc));
    }
    output.push('\n');

    // Generate field definitions
    for field in &message_info.fields {
        let python_type = convert_protobuf_field_to_python_type(&field.field_type, field.optional);
        output.push_str(&format!("    {}: {}\n", field.name, python_type));
        if let Some(doc) = &field.documentation {
            let cleaned_doc = clean_documentation(doc);
            output.push_str(&format!("    \"\"\"{}.\"\"\"\n", cleaned_doc));
        }
        output.push('\n');
    }

    // Generate constructor
    output.push_str(&generate_constructor_for_message(message_info));

    output
}

/// Generate constructor for a message type
fn generate_constructor_for_message(message_info: &MessageInfo) -> String {
    let mut output = String::from("    def __init__(\n        self,\n");

    // Required fields first
    for field in &message_info.fields {
        if !field.optional && !field.repeated {
            let python_type = convert_protobuf_field_to_python_type(&field.field_type, false);
            output.push_str(&format!("        {}: {},\n", field.name, python_type));
        }
    }

    // Optional fields with defaults
    for field in &message_info.fields {
        if field.optional || field.repeated {
            let python_type = convert_protobuf_field_to_python_type(&field.field_type, true);
            output.push_str(&format!(
                "        {}: {} = None,\n",
                field.name, python_type
            ));
        }
    }

    output.push_str("    ) -> None: ...\n");
    output
}

/// Convert protobuf field type to Python type annotation
fn convert_protobuf_field_to_python_type(field_type: &str, is_optional: bool) -> String {
    let base_type = match field_type {
        "TYPE_STRING" => "str",
        "TYPE_INT32" => "int",
        "TYPE_INT64" => "int",
        "TYPE_BOOL" => "bool",
        "TYPE_DOUBLE" => "float",
        "TYPE_FLOAT" => "float",
        "TYPE_BYTES" => "bytes",
        _ => {
            if field_type.ends_with("PropertiesEntry") {
                "Dict[str, str]"
            } else if field_type.starts_with("TYPE_MESSAGE:") {
                extract_simple_type_name(&field_type[13..])
            } else if field_type.starts_with("TYPE_ENUM:") {
                extract_simple_type_name(&field_type[10..])
            } else if field_type.starts_with("TYPE_ONEOF:") {
                extract_simple_type_name(&field_type[11..])
            } else {
                "Any"
            }
        }
    };

    if is_optional {
        format!("Optional[{}]", base_type)
    } else {
        base_type.to_string()
    }
}

/// Extract simple type name from fully qualified protobuf type
fn extract_simple_type_name(full_type: &str) -> &str {
    // Remove leading dots and extract the last component
    let trimmed = full_type.trim_start_matches('.');
    trimmed.split('.').next_back().unwrap_or(trimmed)
}

/// Clean documentation text by removing trailing periods and extra whitespace
fn clean_documentation(doc: &str) -> String {
    doc.trim().trim_end_matches('.').trim().to_string()
}

/// Generate client classes section
fn generate_client_classes_section(services: &[ServicePlan]) -> String {
    let mut output = String::from("# Client classes\n\n");

    // Generate individual resource client classes
    output.push_str(&generate_resource_client_classes());

    // Generate main client class
    output.push_str(&generate_main_client_class(services));

    output
}

/// Generate resource client classes
fn generate_resource_client_classes() -> String {
    r#"class CatalogClient:
    """Client for operations on a specific catalog."""

    def get(self, include_browse: Optional[bool] = None) -> CatalogInfo:
        """Get information about this catalog."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> CatalogInfo:
        """Update this catalog."""
        ...

    def delete(self, force: Optional[bool] = None) -> None:
        """Delete this catalog."""
        ...

class SchemaClient:
    """Client for operations on a specific schema."""

    def get(self, include_browse: Optional[bool] = None) -> SchemaInfo:
        """Get information about this schema."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> SchemaInfo:
        """Update this schema."""
        ...

    def delete(self, force: Optional[bool] = None) -> None:
        """Delete this schema."""
        ...

class TableClient:
    """Client for operations on a specific table."""

    def get(
        self,
        include_delta_metadata: Optional[bool] = None,
        include_browse: Optional[bool] = None,
        include_manifest_capabilities: Optional[bool] = None,
    ) -> TableInfo:
        """Get information about this table."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> TableInfo:
        """Update this table."""
        ...

    def delete(self) -> None:
        """Delete this table."""
        ...

class VolumeClient:
    """Client for operations on a specific volume."""

    def get(self, include_browse: Optional[bool] = None) -> VolumeInfo:
        """Get information about this volume."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
    ) -> VolumeInfo:
        """Update this volume."""
        ...

    def delete(self) -> None:
        """Delete this volume."""
        ...

class ShareClient:
    """Client for operations on a specific share."""

    def get(self, include_shared_data: Optional[bool] = None) -> ShareInfo:
        """Get information about this share."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
        updates: Optional[List[DataObjectUpdate]] = None,
    ) -> ShareInfo:
        """Update this share."""
        ...

    def delete(self) -> None:
        """Delete this share."""
        ...

class RecipientClient:
    """Client for operations on a specific recipient."""

    def get(self) -> RecipientInfo:
        """Get information about this recipient."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
        ip_access_list: Optional[List[str]] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> RecipientInfo:
        """Update this recipient."""
        ...

    def delete(self) -> None:
        """Delete this recipient."""
        ...

class CredentialClient:
    """Client for operations on a specific credential."""

    def get(self) -> CredentialInfo:
        """Get information about this credential."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
        force: Optional[bool] = None,
        credential: Optional[Union[AzureServicePrincipal, AzureManagedIdentity, AzureStorageKey]] = None,
    ) -> CredentialInfo:
        """Update this credential."""
        ...

    def delete(self) -> None:
        """Delete this credential."""
        ...

class ExternalLocationClient:
    """Client for operations on a specific external location."""

    def get(self) -> ExternalLocationInfo:
        """Get information about this external location."""
        ...

    def update(
        self,
        new_name: Optional[str] = None,
        url: Optional[str] = None,
        credential_name: Optional[str] = None,
        comment: Optional[str] = None,
        owner: Optional[str] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
        force: Optional[bool] = None,
    ) -> ExternalLocationInfo:
        """Update this external location."""
        ...

    def delete(self, force: Optional[bool] = None) -> None:
        """Delete this external location."""
        ...

class TemporaryCredentialClient:
    """Client for managing temporary credentials."""

    def temporary_table_credential(
        self,
        table: str,
        operation: Literal["read", "read_write"],
    ) -> Tuple[TemporaryCredential, str]:
        """Generate temporary credentials for accessing a table."""
        ...

    def temporary_path_credential(
        self,
        path: str,
        operation: Literal["read", "read_write", "create_table"],
        dry_run: Optional[bool] = None,
    ) -> Tuple[TemporaryCredential, str]:
        """Generate temporary credentials for accessing a storage path."""
        ...

class SharingClient:
    """Client for Delta Sharing operations."""

    def __init__(
        self,
        base_url: str,
        token: Optional[str] = None,
        prefix: Optional[str] = None,
    ) -> None:
        """Initialize a Delta Sharing client."""
        ...

    def list_shares(self, max_results: Optional[int] = None) -> List[Share]:
        """List available shares."""
        ...

    def get_share(self, name: str) -> Share:
        """Get information about a specific share."""
        ...

    def list_share_schemas(
        self, share: str, max_results: Optional[int] = None
    ) -> List[SharingSchema]:
        """List schemas in a share."""
        ...

    def list_share_tables(
        self, share: str, max_results: Optional[int] = None
    ) -> List[SharingTable]:
        """List tables in a share."""
        ...

    def list_schema_tables(
        self, share: str, schema: str, max_results: Optional[int] = None
    ) -> List[SharingTable]:
        """List tables in a schema within a share."""
        ...

    def get_table_version(
        self,
        share: str,
        schema: str,
        table: str,
        starting_timestamp: Optional[str] = None,
    ) -> int:
        """Get the current version of a table."""
        ...

    def get_table_metadata(
        self, share: str, schema: str, table: str
    ) -> Tuple[Protocol, Metadata]:
        """Get metadata for a table."""
        ...

"#
    .to_string()
}

/// Generate main client class
fn generate_main_client_class(_services: &[ServicePlan]) -> String {
    r#"# Main Unity Catalog client

class UnityCatalogClient:
    """Unity Catalog client for managing catalogs, schemas, tables, and more."""

    def __init__(self, base_url: str, token: Optional[str] = None) -> None:
        """Initialize a Unity Catalog client.

        Args:
            base_url: The base URL of the Unity Catalog API.
            token: Personal Access Token for authentication.
        """
        ...

    # Collection methods - Catalogs
    def list_catalogs(
        self,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
    ) -> List[CatalogInfo]:
        """List all catalogs.

        Gets an array of catalogs in the metastore. If the caller is the metastore admin,
        all catalogs will be retrieved. Otherwise, only catalogs owned by the caller
        (or for which the caller has the USE_CATALOG privilege) will be retrieved.
        """
        ...

    def create_catalog(
        self,
        name: str,
        storage_root: Optional[str] = None,
        comment: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> CatalogInfo:
        """Create a new managed catalog."""
        ...

    def create_sharing_catalog(
        self,
        name: str,
        provider_name: str,
        share_name: str,
        comment: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> CatalogInfo:
        """Create a new sharing catalog."""
        ...

    # Collection methods - Schemas
    def list_schemas(
        self,
        catalog_name: str,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
    ) -> List[SchemaInfo]:
        """List schemas in a catalog."""
        ...

    def create_schema(
        self,
        catalog_name: str,
        schema_name: str,
        comment: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> SchemaInfo:
        """Create a new schema."""
        ...

    # Collection methods - Tables
    def list_tables(
        self,
        catalog_name: str,
        schema_name: str,
        max_results: Optional[int] = None,
        include_delta_metadata: Optional[bool] = None,
        omit_columns: Optional[bool] = None,
        omit_properties: Optional[bool] = None,
        omit_username: Optional[bool] = None,
        include_browse: Optional[bool] = None,
    ) -> List[TableInfo]:
        """List tables in a schema."""
        ...

    def create_table(
        self,
        catalog_name: str,
        schema_name: str,
        table_name: str,
        table_type: TableType,
        data_source_format: DataSourceFormat,
        columns: List[ColumnInfo],
        storage_location: Optional[str] = None,
        comment: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> TableInfo:
        """Create a new table."""
        ...

    # Collection methods - Volumes
    def list_volumes(
        self,
        catalog_name: str,
        schema_name: str,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
    ) -> List[VolumeInfo]:
        """List volumes in a schema."""
        ...

    def create_volume(
        self,
        catalog_name: str,
        schema_name: str,
        volume_name: str,
        volume_type: VolumeType,
        storage_location: Optional[str] = None,
        comment: Optional[str] = None,
    ) -> VolumeInfo:
        """Create a new volume."""
        ...

    # Collection methods - Shares
    def list_shares(
        self,
        max_results: Optional[int] = None,
    ) -> List[ShareInfo]:
        """List all shares."""
        ...

    def create_share(
        self,
        name: str,
        comment: Optional[str] = None,
    ) -> ShareInfo:
        """Create a new share."""
        ...

    # Collection methods - Recipients
    def list_recipients(
        self,
        max_results: Optional[int] = None,
    ) -> List[RecipientInfo]:
        """List all recipients."""
        ...

    def create_recipient(
        self,
        name: str,
        authentication_type: AuthenticationType,
        comment: Optional[str] = None,
        ip_access_list: Optional[List[str]] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> RecipientInfo:
        """Create a new recipient."""
        ...

    # Collection methods - Credentials
    def list_credentials(
        self,
        purpose: Optional[Purpose] = None,
        max_results: Optional[int] = None,
    ) -> List[CredentialInfo]:
        """List all credentials."""
        ...

    def create_credential(
        self,
        name: str,
        purpose: Purpose,
        comment: Optional[str] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
        credential: Optional[Union[AzureServicePrincipal, AzureManagedIdentity, AzureStorageKey]] = None,
    ) -> CredentialInfo:
        """Create a new credential."""
        ...

    # Collection methods - External Locations
    def list_external_locations(
        self,
        max_results: Optional[int] = None,
    ) -> List[ExternalLocationInfo]:
        """List all external locations."""
        ...

    def create_external_location(
        self,
        name: str,
        url: str,
        credential_name: str,
        comment: Optional[str] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
    ) -> ExternalLocationInfo:
        """Create a new external location."""
        ...

    # Resource accessor methods
    def catalog(self, name: str) -> CatalogClient:
        """Get a client for operations on a specific catalog."""
        ...

    def schema(self, catalog_name: str, schema_name: str) -> SchemaClient:
        """Get a client for operations on a specific schema."""
        ...

    def table(self, full_name: str) -> TableClient:
        """Get a client for operations on a specific table."""
        ...

    def volume(
        self, catalog_name: str, schema_name: str, volume_name: str
    ) -> VolumeClient:
        """Get a client for operations on a specific volume."""
        ...

    def share(self, name: str) -> ShareClient:
        """Get a client for operations on a specific share."""
        ...

    def recipient(self, name: str) -> RecipientClient:
        """Get a client for operations on a specific recipient."""
        ...

    def credential(self, name: str) -> CredentialClient:
        """Get a client for operations on a specific credential."""
        ...

    def external_location(self, name: str) -> ExternalLocationClient:
        """Get a client for operations on a specific external location."""
        ...

    def temporary_credentials(self) -> TemporaryCredentialClient:
        """Get a client for managing temporary credentials."""
        ...
"#
    .to_string()
}
