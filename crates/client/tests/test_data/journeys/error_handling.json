{
  "name": "error_handling",
  "description": "Error handling journey testing various failure scenarios and error conditions",
  "variables": {
    "nonexistent_catalog": "catalog_that_does_not_exist",
    "invalid_catalog_name": "invalid-catalog-name!@#",
    "existing_catalog": "test_existing_catalog",
    "conflicting_catalog": "test_conflict_catalog"
  },
  "steps": [
    {
      "id": "get_nonexistent_catalog",
      "description": "Attempt to get a catalog that doesn't exist",
      "method": "GET",
      "path": "/catalogs/{nonexistent_catalog}",
      "expected_status": 404,
      "expected_response": {
        "error_code": "RESOURCE_DOES_NOT_EXIST",
        "message": "Catalog '{nonexistent_catalog}' not found",
        "details": {
          "resource_type": "catalog",
          "resource_name": "{nonexistent_catalog}"
        }
      },
      "tags": ["error", "not_found", "catalog"]
    },
    {
      "id": "create_catalog_invalid_name",
      "description": "Attempt to create catalog with invalid name",
      "method": "POST",
      "path": "/catalogs",
      "request_body": {
        "name": "{invalid_catalog_name}",
        "storage_root": "s3://test-bucket/catalogs/",
        "comment": "Invalid catalog name test"
      },
      "expected_status": 400,
      "expected_response": {
        "error_code": "INVALID_PARAMETER_VALUE",
        "message": "Invalid catalog name: '{invalid_catalog_name}'. Catalog names must contain only alphanumeric characters, underscores, and hyphens.",
        "details": {
          "parameter": "name",
          "value": "{invalid_catalog_name}",
          "constraint": "alphanumeric_underscore_hyphen_only"
        }
      },
      "tags": ["error", "validation", "catalog", "bad_request"]
    },
    {
      "id": "create_catalog_missing_storage",
      "description": "Attempt to create catalog without required storage_root",
      "method": "POST",
      "path": "/catalogs",
      "request_body": {
        "name": "test_missing_storage",
        "comment": "Missing storage root test"
      },
      "expected_status": 400,
      "expected_response": {
        "error_code": "INVALID_PARAMETER_VALUE",
        "message": "Missing required parameter: storage_root",
        "details": {
          "parameter": "storage_root",
          "constraint": "required"
        }
      },
      "tags": ["error", "validation", "catalog", "missing_parameter"]
    },
    {
      "id": "setup_existing_catalog",
      "description": "Create a catalog that we'll use for conflict testing",
      "method": "POST",
      "path": "/catalogs",
      "request_body": {
        "name": "{existing_catalog}",
        "storage_root": "s3://test-bucket/catalogs/",
        "comment": "Catalog for conflict testing"
      },
      "expected_status": 201,
      "expected_response": {
        "name": "{existing_catalog}",
        "comment": "Catalog for conflict testing",
        "storage_root": "s3://test-bucket/catalogs/",
        "owner": "test-user",
        "created_at": 1699564800000,
        "updated_at": 1699564800000,
        "catalog_type": "MANAGED_CATALOG",
        "provider_name": null,
        "share_name": null,
        "isolation_mode": "OPEN",
        "options": {},
        "effective_predictive_optimization_flag": {
          "value": "INHERIT",
          "inherited_from_type": "SYSTEM_DEFAULT"
        }
      },
      "extract_variables": {
        "existing_catalog_created_at": "$.created_at"
      },
      "tags": ["setup", "catalog"]
    },
    {
      "id": "create_duplicate_catalog",
      "description": "Attempt to create catalog that already exists",
      "method": "POST",
      "path": "/catalogs",
      "request_body": {
        "name": "{existing_catalog}",
        "storage_root": "s3://test-bucket/catalogs/",
        "comment": "Duplicate catalog test"
      },
      "expected_status": 409,
      "expected_response": {
        "error_code": "RESOURCE_ALREADY_EXISTS",
        "message": "Catalog '{existing_catalog}' already exists",
        "details": {
          "resource_type": "catalog",
          "resource_name": "{existing_catalog}",
          "existing_resource_id": "{existing_catalog}"
        }
      },
      "depends_on": ["setup_existing_catalog"],
      "tags": ["error", "conflict", "catalog"]
    },
    {
      "id": "update_nonexistent_catalog",
      "description": "Attempt to update a catalog that doesn't exist",
      "method": "PATCH",
      "path": "/catalogs/{nonexistent_catalog}",
      "request_body": {
        "comment": "Updated comment for nonexistent catalog"
      },
      "expected_status": 404,
      "expected_response": {
        "error_code": "RESOURCE_DOES_NOT_EXIST",
        "message": "Catalog '{nonexistent_catalog}' not found",
        "details": {
          "resource_type": "catalog",
          "resource_name": "{nonexistent_catalog}"
        }
      },
      "tags": ["error", "not_found", "catalog", "update"]
    },
    {
      "id": "delete_nonexistent_catalog",
      "description": "Attempt to delete a catalog that doesn't exist",
      "method": "DELETE",
      "path": "/catalogs/{nonexistent_catalog}",
      "expected_status": 404,
      "expected_response": {
        "error_code": "RESOURCE_DOES_NOT_EXIST",
        "message": "Catalog '{nonexistent_catalog}' not found",
        "details": {
          "resource_type": "catalog",
          "resource_name": "{nonexistent_catalog}"
        }
      },
      "tags": ["error", "not_found", "catalog", "delete"]
    },
    {
      "id": "create_schema_in_nonexistent_catalog",
      "description": "Attempt to create schema in catalog that doesn't exist",
      "method": "POST",
      "path": "/schemas",
      "request_body": {
        "name": "test_schema",
        "catalog_name": "{nonexistent_catalog}",
        "comment": "Schema in nonexistent catalog"
      },
      "expected_status": 404,
      "expected_response": {
        "error_code": "RESOURCE_DOES_NOT_EXIST",
        "message": "Parent catalog '{nonexistent_catalog}' not found",
        "details": {
          "resource_type": "catalog",
          "resource_name": "{nonexistent_catalog}",
          "operation": "create_schema"
        }
      },
      "tags": ["error", "not_found", "schema", "parent_dependency"]
    },
    {
      "id": "get_nonexistent_schema",
      "description": "Attempt to get a schema that doesn't exist",
      "method": "GET",
      "path": "/schemas/{existing_catalog}.nonexistent_schema",
      "expected_status": 404,
      "expected_response": {
        "error_code": "RESOURCE_DOES_NOT_EXIST",
        "message": "Schema '{existing_catalog}.nonexistent_schema' not found",
        "details": {
          "resource_type": "schema",
          "resource_name": "{existing_catalog}.nonexistent_schema"
        }
      },
      "depends_on": ["setup_existing_catalog"],
      "tags": ["error", "not_found", "schema"]
    },
    {
      "id": "create_table_in_nonexistent_schema",
      "description": "Attempt to create table in schema that doesn't exist",
      "method": "POST",
      "path": "/tables",
      "request_body": {
        "name": "test_table",
        "catalog_name": "{existing_catalog}",
        "schema_name": "nonexistent_schema",
        "comment": "Table in nonexistent schema",
        "table_type": "MANAGED",
        "data_source_format": "DELTA",
        "columns": [
          {
            "name": "id",
            "type_text": "INT",
            "type_name": "INT",
            "position": 0,
            "comment": "ID column",
            "nullable": false
          }
        ]
      },
      "expected_status": 404,
      "expected_response": {
        "error_code": "RESOURCE_DOES_NOT_EXIST",
        "message": "Parent schema '{existing_catalog}.nonexistent_schema' not found",
        "details": {
          "resource_type": "schema",
          "resource_name": "{existing_catalog}.nonexistent_schema",
          "operation": "create_table"
        }
      },
      "depends_on": ["setup_existing_catalog"],
      "tags": ["error", "not_found", "table", "parent_dependency"]
    },
    {
      "id": "create_table_invalid_column_type",
      "description": "Attempt to create table with invalid column type",
      "method": "POST",
      "path": "/tables",
      "request_body": {
        "name": "test_invalid_table",
        "catalog_name": "{existing_catalog}",
        "schema_name": "test_schema",
        "comment": "Table with invalid column type",
        "table_type": "MANAGED",
        "data_source_format": "DELTA",
        "columns": [
          {
            "name": "invalid_col",
            "type_text": "INVALID_TYPE",
            "type_name": "INVALID_TYPE",
            "position": 0,
            "comment": "Invalid column type",
            "nullable": true
          }
        ]
      },
      "expected_status": 400,
      "expected_response": {
        "error_code": "INVALID_PARAMETER_VALUE",
        "message": "Invalid column type: 'INVALID_TYPE'",
        "details": {
          "parameter": "columns[0].type_name",
          "value": "INVALID_TYPE",
          "constraint": "valid_data_type"
        }
      },
      "depends_on": ["setup_existing_catalog"],
      "tags": ["error", "validation", "table", "invalid_type"]
    },
    {
      "id": "unauthorized_operation",
      "description": "Simulate unauthorized access (would normally require auth setup)",
      "method": "DELETE",
      "path": "/catalogs/{existing_catalog}",
      "expected_status": 403,
      "expected_response": {
        "error_code": "PERMISSION_DENIED",
        "message": "User does not have permission to delete catalog '{existing_catalog}'",
        "details": {
          "resource_type": "catalog",
          "resource_name": "{existing_catalog}",
          "required_permission": "DELETE",
          "user": "test-user"
        }
      },
      "depends_on": ["setup_existing_catalog"],
      "tags": ["error", "authorization", "catalog", "permission_denied"]
    },
    {
      "id": "malformed_json_request",
      "description": "Attempt to create catalog with malformed JSON",
      "method": "POST",
      "path": "/catalogs",
      "request_body": {
        "name": "test_malformed",
        "storage_root": "s3://test-bucket/catalogs/",
        "comment": "Test with malformed JSON",
        "properties": "this_should_be_an_object_not_string"
      },
      "expected_status": 400,
      "expected_response": {
        "error_code": "INVALID_PARAMETER_VALUE",
        "message": "Invalid JSON format for field 'properties'",
        "details": {
          "parameter": "properties",
          "expected_type": "object",
          "actual_type": "string"
        }
      },
      "tags": ["error", "validation", "json", "malformed"]
    },
    {
      "id": "rate_limit_simulation",
      "description": "Simulate rate limiting response",
      "method": "GET",
      "path": "/catalogs",
      "expected_status": 429,
      "expected_response": {
        "error_code": "RATE_LIMIT_EXCEEDED",
        "message": "Too many requests. Please try again later.",
        "details": {
          "retry_after_seconds": 60,
          "request_limit": 1000,
          "time_window": "1hour"
        }
      },
      "tags": ["error", "rate_limit", "too_many_requests"]
    },
    {
      "id": "server_error_simulation",
      "description": "Simulate internal server error",
      "method": "GET",
      "path": "/catalogs/{existing_catalog}",
      "expected_status": 500,
      "expected_response": {
        "error_code": "INTERNAL_ERROR",
        "message": "An internal server error occurred",
        "details": {
          "request_id": "req-12345678-1234-1234-1234-123456789012",
          "timestamp": 1699564800000
        }
      },
      "depends_on": ["setup_existing_catalog"],
      "continue_on_failure": true,
      "tags": ["error", "server_error", "internal"]
    },
    {
      "id": "cleanup_existing_catalog",
      "description": "Clean up the catalog created for testing",
      "method": "DELETE",
      "path": "/catalogs/{existing_catalog}",
      "expected_status": 200,
      "depends_on": ["setup_existing_catalog"],
      "continue_on_failure": true,
      "tags": ["cleanup", "catalog"]
    }
  ],
  "metadata": {
    "author": "Unity Catalog Test Framework",
    "created": "2024-01-15",
    "version": "1.0",
    "tags": ["error_handling", "validation", "edge_cases", "negative_testing"],
    "estimated_duration_ms": 8000,
    "description": "Tests various error conditions and edge cases in Unity Catalog API operations"
  }
}
